import org.apache.commons.io.FileUtils
import we.gitUtils.GitUtils
import we.processUtils.ProcessRunner

import javax.inject.Inject
import java.nio.charset.StandardCharsets

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        maven {
            name = 's3Private'
            url = 's3://maven.taruts.net'
            credentials(AwsCredentials) {
                accessKey = 'YCAJEr8kG2QLz00ovJC3oeXiQ'
                secretKey = 'YCMRIR338p1YWdI1089MciPfgEc6_lCi2121XaZM'
            }
        }
    }
    dependencies {
        classpath 'org.apache.commons:commons-lang3:3.12.0'
        classpath 'commons-io:commons-io:2.11.0'
        classpath 'com.google.guava:guava:31.1-jre'
        classpath 'we:process-utils:001'
        classpath 'we:git-utils:001'
        classpath 'javax.inject:javax.inject:1'
    }
}

plugins {
    id 'org.springframework.boot' version '2.6.4'
    id 'io.spring.dependency-management' version '1.0.11.RELEASE'
    id 'application'
}

group = 'we.git-implementations'
sourceCompatibility = '17'

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenLocal()
    mavenCentral()
    maven {
        name = 's3Public'
        url = 's3://public.maven.taruts.net'
        credentials(AwsCredentials) {
            accessKey = 'YCAJEr8kG2QLz00ovJC3oeXiQ'
            secretKey = 'YCMRIR338p1YWdI1089MciPfgEc6_lCi2121XaZM'
        }
    }
    maven {
        name = 's3Private'
        url = 's3://maven.taruts.net'
        credentials(AwsCredentials) {
            accessKey = 'YCAJEr8kG2QLz00ovJC3oeXiQ'
            secretKey = 'YCMRIR338p1YWdI1089MciPfgEc6_lCi2121XaZM'
        }
    }
    mavenCentral()
}

dependencies {
    // Dev tools
    developmentOnly 'org.springframework.boot:spring-boot-devtools'

    // Lombok
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'

    // Spring Boot + WebFlux
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'

    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'

    implementation 'we.git-implementations:dynamic-api:001'

    // Our libraries
    implementation 'we:git-utils:001'
    implementation 'we:gradle-utils:001'

    // Utils
    implementation 'org.apache.commons:commons-lang3'
    implementation 'commons-io:commons-io:2.11.0'
    implementation 'com.google.guava:guava:31.1-jre'

    // Test
    testImplementation 'io.projectreactor:reactor-test'
}

tasks.named('test') {
    useJUnitPlatform()
}

tasks.register('initDynamicLocal') {
    it.group = 'other-git-repos'

    it.description = '''
    Clones dynamic-dev to other-git-repos/dynamic-local, 
    detaches it from the dynamic-dev remote, 
    then linkes it with a newly created remote other-git-repos/dynamic-local/remote
    which is inside.
    '''.stripIndent()

    it.doLast {
        // Вычисляем, куда мы будем клонироваться
        File dynamicLocalDirectory = java.nio.file.Path
            .of(project.rootDir.path, '../other-git-repos/dynamic-local')
            .toAbsolutePath()
            .normalize()
            .toFile()
        // Удаляем этот каталог, если он есть
        if (dynamicLocalDirectory.exists()) {
            FileUtils.forceDelete(dynamicLocalDirectory)
        }
        FileUtils.forceMkdir(dynamicLocalDirectory)

        String resourcesDir = project.sourceSets.main.resources.srcDirs.first()
        File dynamicDevPropertiesFile = FileUtils.getFile(resourcesDir, 'application-dynamic-dev.properties')
        def dynamicDevProperties = new Properties()
        try (Reader reader = dynamicDevPropertiesFile.newReader()) {
            dynamicDevProperties.load(reader)
        }
        String dynamicDevRemoteUrlStr = dynamicDevProperties.get('dynamic-impl.git-repository.url')

        // Клонируемся в каталог build/dynamic-impl-dev
        GitUtils.clone(dynamicDevRemoteUrlStr, dynamicLocalDirectory)

        File settingsGradleFile = FileUtils.getFile(dynamicLocalDirectory, 'settings.gradle')
        FileUtils.writeStringToFile(settingsGradleFile, "rootProject.name = 'dynamic-local'", StandardCharsets.UTF_8)
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'add', '*')
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'commit', '-m', 'Changing project name to dynamic-local')

        // В каталоге, где должен быть remote, содаем репозиторий
        File remoteDirectory = FileUtils.getFile(dynamicLocalDirectory, 'remote')
        FileUtils.forceMkdir(remoteDirectory)
        ProcessRunner.runProcess(remoteDirectory, 'git', 'init', '--bare')

        // Перенаправляем remote origin на наш новый репозиторий
        String remoteUrlStr = "file://$remoteDirectory"
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'remote', 'set-url', 'origin', remoteUrlStr)

        // Пушим все в новый репозиторий
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'push', 'origin', 'master')
    }
}

abstract class InitAdjacentGitRepoTask extends DefaultTask {

    @Input
    final String adjacentRepoPostfix

    private String adjacentRepoUrl
    private File sourceDir

    @Inject
    InitAdjacentGitRepoTask(String adjacentRepoPostfix) {
        this.adjacentRepoPostfix = adjacentRepoPostfix

        this.group = 'other-git-repos'

        // Определяем что клонировать. Вычисляем URL репозитория для клонирования, отталкиваясь от URL текущего репозитория
        String startingPointRepoPostfix = 'main'
        String startingPointRepoUrl = ProcessRunner.runProcess(project.rootDir, 'git', 'remote', 'get-url', 'origin')
        adjacentRepoUrl = startingPointRepoUrl.replaceAll(/$startingPointRepoPostfix(?=\.git$)/, adjacentRepoPostfix)

        // Определяем куда клонировать. Нацеливаемся на каталог, где у нас будут лежать исходники
        sourceDir = FileUtils.getFile(project.rootDir.parent, "other-git-repos", adjacentRepoPostfix)

        this.description = "Clones $adjacentRepoUrl into $sourceDir"
    }

    @TaskAction
    def action() {
        GitUtils.forceClone(adjacentRepoUrl, sourceDir)
    }
}

tasks.register('initDynamicApi', InitAdjacentGitRepoTask, 'dynamic-api')
tasks.register('initDynamicDev', InitAdjacentGitRepoTask, 'dynamic-dev')
