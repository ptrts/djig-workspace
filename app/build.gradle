import org.apache.commons.io.FileUtils
import org.apache.commons.lang3.StringUtils
import org.gitlab4j.api.GitLabApi
import org.gitlab4j.api.GitLabApiException
import org.gitlab4j.api.models.Group
import org.taruts.gitUtils.GitUtils
import org.taruts.processUtils.ProcessRunner

import javax.inject.Inject
import java.nio.charset.StandardCharsets

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        maven {
            name = 's3MavenRepo'
            url = 's3://maven.taruts.net'
            credentials(AwsCredentials)
        }
    }
    dependencies {
        classpath 'org.apache.commons:commons-lang3:3.12.0'
        classpath 'commons-io:commons-io:2.11.0'
        classpath 'com.google.guava:guava:31.1-jre'
        classpath 'we:process-utils:001'
        classpath 'we:git-utils:001'
        classpath 'javax.inject:javax.inject:1'
        classpath 'org.gitlab4j:gitlab4j-api:5.0.1'
    }
}

plugins {
    id 'org.springframework.boot' version '2.6.4'
    id 'io.spring.dependency-management' version '1.0.11.RELEASE'
    id 'application'
}

group = 'we.git-implementations'
sourceCompatibility = '17'

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenLocal()
    mavenCentral()
    maven {
        name = 's3MavenRepo'
        url = 's3://maven.taruts.net'
        credentials(AwsCredentials)
    }
    mavenCentral()
}

dependencies {
    // Dev tools
    developmentOnly 'org.springframework.boot:spring-boot-devtools'

    // Lombok
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'

    // Spring Boot + WebFlux
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'

    // Spring Retry
    implementation 'org.springframework:spring-aspects'
    implementation 'org.springframework.retry:spring-retry:1.2.5.RELEASE'

    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'

    implementation 'we.git-implementations:dynamic-api:001'

    // GitLab API
    implementation 'org.gitlab4j:gitlab4j-api:5.0.1'

    // Our libraries
    implementation 'we:git-utils:001'
    implementation 'we:gradle-utils:001'

    // Utils
    implementation 'org.apache.commons:commons-lang3'
    implementation 'commons-io:commons-io:2.11.0'
    implementation 'com.google.guava:guava:31.1-jre'

    // Test
    testImplementation 'io.projectreactor:reactor-test'
}

tasks.named('test') {
    useJUnitPlatform()
}

tasks.register('initDynamicLocal') {
    it.group = 'app'

    it.description = '''
    Creates a fork of dynamic-dev in the local GitLab
    and clones it into the dynamic-local project subdirectory
    '''.stripIndent()

    it.doLast {
        // Вычисляем, куда мы будем клонироваться
        File dynamicLocalDirectory = java.nio.file.Path
            .of(rootProject.projectDir.path, 'dynamic-local')
            .toAbsolutePath()
            .normalize()
            .toFile()
        // Удаляем этот каталог, если он есть
        if (dynamicLocalDirectory.exists()) {
            FileUtils.forceDelete(dynamicLocalDirectory)
        }
        FileUtils.forceMkdir(dynamicLocalDirectory)

        // Из основного проекта берем URL репозитория dynamic-dev
        GitLabParameters devGitLabParameters = GitLabParameters.getGitLabParameters(project, 'application-dynamic-dev.properties')

        // Клонируемся в каталог build/dynamic-impl-dev
        GitUtils.clone(devGitLabParameters.projectUri.toString(), dynamicLocalDirectory)

        // Ставим пользователя и его мейл
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'config', '--local', 'user.name', 'user')
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'config', '--local', 'user.email', 'user@mail.com')

        // Изменяем имя проекта и коммитим это
        File settingsGradleFile = FileUtils.getFile(dynamicLocalDirectory, 'settings.gradle')
        FileUtils.writeStringToFile(settingsGradleFile, "rootProject.name = 'dynamic-local'", StandardCharsets.UTF_8)
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'add', '*')
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'commit', '-m', 'Changing project name to dynamic-local')

        GitLabParameters localGitLabParameters = GitLabParameters.getGitLabParameters(project, 'application-dynamic-local.properties')

        // Create a GitLabApi instance to communicate with your GitLab server
        GitLabApi gitLabApi = GitLabApi.oauth2Login(
            localGitLabParameters.gitlabUri.toString(),
            localGitLabParameters.username,
            localGitLabParameters.password,
            true
        )

        List<String> pathParts = Arrays
            .stream(
                localGitLabParameters.projectUri.path.split('/')
            )
            .filter(StringUtils::isNotBlank)
            .toList()
        String projectFileName = pathParts.get(pathParts.size() - 1)

        int dotIndex = projectFileName.lastIndexOf('.')
        String projectName = dotIndex == -1
            ? projectFileName
            : projectFileName.substring(0, dotIndex)

        String groupPath = String.join('/', pathParts.subList(0, pathParts.size() - 1))

        // Ищем или создаем группу проектов
        Group group = gitLabApi.getGroupApi().getOptionalGroup(groupPath)
            .orElseGet {
                gitLabApi.getGroupApi().addGroup('Dynamic Java code stored in Git', groupPath)
            }

        org.gitlab4j.api.models.Project gitlabProject

        // Ищем или создаем проект
        gitLabApi.getProjectApi().getOptionalProject(groupPath, projectName)
            .ifPresent {
                gitLabApi.getProjectApi().deleteProject(it.id)
                println('Waiting for project deletion...')
                int i = 60
                for (; i > 0; i--) {
                    gitlabProject = gitLabApi.getProjectApi().getOptionalProject(groupPath, projectName).orElse(null)
                    if (gitlabProject == null) {
                        break
                    }
                    println("$i...")
                    Thread.sleep(1000)
                }
                if (i == 0) {
                    throw new RuntimeException("Could not delete project $projectName")
                }
            }

        for (i in 100..1) {
            try {
                gitlabProject = gitLabApi.getProjectApi().createProject(group.id, projectName)
                break
            } catch (GitLabApiException e) {
                if (i == 1) {
                    throw e
                } else {
                    e.validationErrors.forEach { key, value ->
                        println("Gitlab project creation error: attempt $i, key = ${key}, value = ${value}")
                    }
                    Thread.sleep(1000)
                }
            }
        }

        assert gitlabProject != null

        String remoteUrlStr = gitlabProject.getHttpUrlToRepo()
        URI remoteUri = new URI(remoteUrlStr)

        // Добавляем логин и пароль. Меняем хост и порт
        remoteUri = new URI(
            remoteUri.scheme,
            "${localGitLabParameters.username}:${localGitLabParameters.password}",
            localGitLabParameters.gitlabUri.host,
            localGitLabParameters.gitlabUri.port,
            remoteUri.path,
            null,
            null
        )

        remoteUrlStr = remoteUri.toString()

        // Перенаправляем remote origin на наш новый репозиторий
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'remote', 'set-url', 'origin', remoteUrlStr)

        // Пушим все в новый репозиторий
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'push', 'origin', 'master')
    }
}

abstract class InitAdjacentGitRepoTask extends DefaultTask {

    private static final String STARTING_POINT_REPO_POSTFIX = 'main'

    @Input
    final String adjacentRepoPostfix

    @Inject
    InitAdjacentGitRepoTask(String adjacentRepoPostfix) {
        this.adjacentRepoPostfix = adjacentRepoPostfix

        this.group = 'app'
        this.description = "Clones the $adjacentRepoPostfix project into the project subdirectory with the same name"
    }

    @TaskAction
    def action() {
        // Определяем что клонировать. Вычисляем URL репозитория для клонирования, отталкиваясь от URL текущего репозитория
        String startingPointRepoUrl = ProcessRunner.runProcess(project.projectDir, 'git', 'remote', 'get-url', 'origin')

        // В URL нашего Git репозитория, фрагмент STARTING_POINT_REPO_POSTFIX в конце, перед ".git" заменяем на другое
        String adjacentRepoUrl = startingPointRepoUrl.replaceAll(
            /$STARTING_POINT_REPO_POSTFIX(?=\.git$)/,
            adjacentRepoPostfix
        )

        // Определяем куда клонировать. Нацеливаемся на каталог, где у нас будут лежать исходники
        String sourceDir = FileUtils.getFile(project.rootDir, adjacentRepoPostfix)

        GitUtils.forceClone(adjacentRepoUrl, sourceDir)
    }
}

tasks.register('initDynamicApi', InitAdjacentGitRepoTask, 'dynamic-api')
tasks.register('initDynamicDev', InitAdjacentGitRepoTask, 'dynamic-dev')

tasks.register('initLocalGitLab') {
    it.group = 'app'

    it.description = '''
    Creates a local GitLab Docker container, 
    creates in there a project which is a fork of dynamic-dev 
    and clones it into the dynamic-local project subdirectory
    '''.stripIndent()

    it.dependsOn(':gitlab-container:createAll', 'initDynamicLocal')
}

initDynamicLocal.configure {
    it.shouldRunAfter(':gitlab-container:createAll')
}

tasks.register('init') {
    it.group = 'app'

    it.description = '''
    Initializes everything for the project. 
    This is an aggregate task for initLocalGitLab, initDynamicApi and initDynamicDev
    '''.stripIndent()

    it.dependsOn('initLocalGitLab', 'initDynamicApi', 'initDynamicDev')
}

initDynamicApi.configure {
    it.shouldRunAfter('initLocalGitLab')
}

initDynamicDev.configure {
    it.shouldRunAfter('initLocalGitLab')
}
