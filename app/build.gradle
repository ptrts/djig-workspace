import org.apache.commons.io.FileUtils
import org.apache.commons.lang3.StringUtils
import org.gitlab4j.api.GitLabApi
import org.gitlab4j.api.GitLabApiException
import org.gitlab4j.api.models.Group
import org.taruts.gitUtils.GitUtils
import org.taruts.processUtils.ProcessRunner

import javax.inject.Inject
import java.nio.charset.StandardCharsets

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        maven {
            name = 's3Private'
            url = 's3://maven.taruts.net'
            credentials(AwsCredentials) {
                accessKey = 'YCAJEr8kG2QLz00ovJC3oeXiQ'
                secretKey = 'YCMRIR338p1YWdI1089MciPfgEc6_lCi2121XaZM'
            }
        }
    }
    dependencies {
        classpath 'org.apache.commons:commons-lang3:3.12.0'
        classpath 'commons-io:commons-io:2.11.0'
        classpath 'com.google.guava:guava:31.1-jre'
        classpath 'we:process-utils:001'
        classpath 'we:git-utils:001'
        classpath 'javax.inject:javax.inject:1'
        classpath 'org.gitlab4j:gitlab4j-api:5.0.1'
    }
}

plugins {
    id 'org.springframework.boot' version '2.6.4'
    id 'io.spring.dependency-management' version '1.0.11.RELEASE'
    id 'application'
}

group = 'we.git-implementations'
sourceCompatibility = '17'

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenLocal()
    mavenCentral()
    maven {
        name = 's3Public'
        url = 's3://public.maven.taruts.net'
        credentials(AwsCredentials) {
            accessKey = 'YCAJEr8kG2QLz00ovJC3oeXiQ'
            secretKey = 'YCMRIR338p1YWdI1089MciPfgEc6_lCi2121XaZM'
        }
    }
    maven {
        name = 's3Private'
        url = 's3://maven.taruts.net'
        credentials(AwsCredentials) {
            accessKey = 'YCAJEr8kG2QLz00ovJC3oeXiQ'
            secretKey = 'YCMRIR338p1YWdI1089MciPfgEc6_lCi2121XaZM'
        }
    }
    mavenCentral()
}

dependencies {
    // Dev tools
    developmentOnly 'org.springframework.boot:spring-boot-devtools'

    // Lombok
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'

    // Spring Boot + WebFlux
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'

    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'

    implementation 'we.git-implementations:dynamic-api:001'

    // GitLab API
    implementation 'org.gitlab4j:gitlab4j-api:5.0.1'

    // Our libraries
    implementation 'we:git-utils:001'
    implementation 'we:gradle-utils:001'

    // Utils
    implementation 'org.apache.commons:commons-lang3'
    implementation 'commons-io:commons-io:2.11.0'
    implementation 'com.google.guava:guava:31.1-jre'

    // Test
    testImplementation 'io.projectreactor:reactor-test'
}

tasks.named('test') {
    useJUnitPlatform()
}

tasks.register('initDynamicLocal') {
    it.group = 'gitlab-container'

    it.description = '''
    Clones dynamic-dev to dynamic-local, 
    detaches it from the dynamic-dev remote, 
    then linkes it with a newly created remote dynamic-local/remote
    which is inside.
    '''.stripIndent()

    it.doLast {
        // Вычисляем, куда мы будем клонироваться
        File dynamicLocalDirectory = java.nio.file.Path
            .of(rootProject.projectDir.path, 'dynamic-local')
            .toAbsolutePath()
            .normalize()
            .toFile()
        // Удаляем этот каталог, если он есть
        if (dynamicLocalDirectory.exists()) {
            FileUtils.forceDelete(dynamicLocalDirectory)
        }
        FileUtils.forceMkdir(dynamicLocalDirectory)

        String resourcesDir = project.sourceSets.main.resources.srcDirs.first()

        // Из основного проекта берем URL репозитория dynamic-dev
        File dynamicDevPropertiesFile = FileUtils.getFile(resourcesDir, 'application-dynamic-dev.properties')
        def dynamicDevProperties = new Properties()
        try (Reader reader = dynamicDevPropertiesFile.newReader()) {
            dynamicDevProperties.load(reader)
        }
        String dynamicDevRemoteUrlStr = dynamicDevProperties.get('dynamic-impl.git-repository.url')

        // Клонируемся в каталог build/dynamic-impl-dev
        GitUtils.clone(dynamicDevRemoteUrlStr, dynamicLocalDirectory)

        // Ставим пользователя и его мейл
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'config', '--local', 'user.name', 'user')
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'config', '--local', 'user.email', 'user@mail.com')

        // Изменяем имя проекта и коммитим это
        File settingsGradleFile = FileUtils.getFile(dynamicLocalDirectory, 'settings.gradle')
        FileUtils.writeStringToFile(settingsGradleFile, "rootProject.name = 'dynamic-local'", StandardCharsets.UTF_8)
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'add', '*')
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'commit', '-m', 'Changing project name to dynamic-local')

        File localGitlabPropertiesFile = FileUtils.getFile(resourcesDir, 'application-dynamic-local.properties')
        def localGitlabProperties = new Properties()
        try (Reader reader = localGitlabPropertiesFile.newReader()) {
            localGitlabProperties.load(reader)
        }

        String propertiesProjectUrlStr = localGitlabProperties.getProperty('dynamic-impl.git-repository.url')
        String propertiesUsername = localGitlabProperties.getProperty('dynamic-impl.git-repository.username')
        String propertiesPassword = localGitlabProperties.getProperty('dynamic-impl.git-repository.password')

        URI propertiesProjectUri = new URI(propertiesProjectUrlStr)
        URI propertiesGitlabUri = new URI(propertiesProjectUri.scheme, propertiesProjectUri.authority, null, null, null)

        // Create a GitLabApi instance to communicate with your GitLab server
        GitLabApi gitLabApi = GitLabApi.oauth2Login(propertiesGitlabUri.toString(), propertiesUsername, propertiesPassword, true)

        List<String> pathParts = Arrays
            .stream(
                propertiesProjectUri.path.split('/')
            )
            .filter(StringUtils::isNotBlank)
            .toList()
        String projectFileName = pathParts.get(pathParts.size() - 1)

        int dotIndex = projectFileName.lastIndexOf('.')
        String projectName = dotIndex == -1
            ? projectFileName
            : projectFileName.substring(0, dotIndex)

        String groupPath = String.join('/', pathParts.subList(0, pathParts.size() - 1))

        // Ищем или создаем группу проектов
        Group group = gitLabApi.getGroupApi().getOptionalGroup(groupPath)
            .orElseGet {
                gitLabApi.getGroupApi().addGroup('Dynamic Java code stored in Git', groupPath)
            }

        org.gitlab4j.api.models.Project gitlabProject

        // Ищем или создаем проект
        gitLabApi.getProjectApi().getOptionalProject(groupPath, projectName)
            .ifPresent {
                gitLabApi.getProjectApi().deleteProject(it.id)
                println('Waiting for project deletion...')
                int i = 60
                for (; i > 0; i--) {
                    gitlabProject = gitLabApi.getProjectApi().getOptionalProject(groupPath, projectName).orElse(null)
                    if (gitlabProject == null) {
                        break
                    }
                    println("$i...")
                    Thread.sleep(1000)
                }
                if (i == 0) {
                    throw new RuntimeException("Could not delete project $projectName")
                }
            }

        for (i in 100..1) {
            try {
                gitlabProject = gitLabApi.getProjectApi().createProject(group.id, projectName)
                break
            } catch (GitLabApiException e) {
                if (i == 1) {
                    throw e
                } else {
                    e.validationErrors.forEach { key, value ->
                        println("Gitlab project creation error: attempt $i, key = ${key}, value = ${value}")
                    }
                    Thread.sleep(1000)
                }
            }
        }

        assert gitlabProject != null

        String remoteUrlStr = gitlabProject.getHttpUrlToRepo()
        URI remoteUri = new URI(remoteUrlStr)

        // Добавляем логин и пароль. Меняем хост и порт
        remoteUri = new URI(
            remoteUri.scheme,
            "$propertiesUsername:$propertiesPassword",
            propertiesGitlabUri.host,
            propertiesGitlabUri.port,
            remoteUri.path,
            null,
            null
        )

        remoteUrlStr = remoteUri.toString()

        // Перенаправляем remote origin на наш новый репозиторий
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'remote', 'set-url', 'origin', remoteUrlStr)

        // Пушим все в новый репозиторий
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'push', 'origin', 'master')
    }
}

abstract class InitAdjacentGitRepoTask extends DefaultTask {

    @Input
    final String adjacentRepoPostfix

    private String adjacentRepoUrl
    private File sourceDir

    @Inject
    InitAdjacentGitRepoTask(String adjacentRepoPostfix) {
        this.adjacentRepoPostfix = adjacentRepoPostfix

        this.group = 'other-git-repos'

        // Определяем что клонировать. Вычисляем URL репозитория для клонирования, отталкиваясь от URL текущего репозитория
        String startingPointRepoPostfix = 'main'
        String startingPointRepoUrl = ProcessRunner.runProcess(project.projectDir, 'git', 'remote', 'get-url', 'origin')
        adjacentRepoUrl = startingPointRepoUrl.replaceAll(/$startingPointRepoPostfix(?=\.git$)/, adjacentRepoPostfix)

        // Определяем куда клонировать. Нацеливаемся на каталог, где у нас будут лежать исходники
        sourceDir = FileUtils.getFile(project.rootDir, adjacentRepoPostfix)

        this.description = "Clones $adjacentRepoUrl into $sourceDir"
    }

    @TaskAction
    def action() {
        GitUtils.forceClone(adjacentRepoUrl, sourceDir)
    }
}

tasks.register('initDynamicApi', InitAdjacentGitRepoTask, 'dynamic-api')
tasks.register('initDynamicDev', InitAdjacentGitRepoTask, 'dynamic-dev')

tasks.register('initLocalGitLab') {
    it.group = 'gitlab-container'
    it.dependsOn(':gitlab-container:createAll', 'initDynamicLocal')
}

initDynamicLocal.configure {
    it.shouldRunAfter(':gitlab-container:createAll')
}
