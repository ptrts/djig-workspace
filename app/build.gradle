import org.apache.commons.io.FileUtils
import org.gitlab4j.api.GitLabApi
import org.gitlab4j.api.GitLabApiException
import org.gitlab4j.api.models.Group
import we.gitUtils.GitUtils
import we.processUtils.ProcessRunner

import javax.inject.Inject
import java.nio.charset.StandardCharsets

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        maven {
            name = 's3Private'
            url = 's3://maven.taruts.net'
            credentials(AwsCredentials) {
                accessKey = 'YCAJEr8kG2QLz00ovJC3oeXiQ'
                secretKey = 'YCMRIR338p1YWdI1089MciPfgEc6_lCi2121XaZM'
            }
        }
    }
    dependencies {
        classpath 'org.apache.commons:commons-lang3:3.12.0'
        classpath 'commons-io:commons-io:2.11.0'
        classpath 'com.google.guava:guava:31.1-jre'
        classpath 'we:process-utils:001'
        classpath 'we:git-utils:001'
        classpath 'javax.inject:javax.inject:1'
        classpath 'org.gitlab4j:gitlab4j-api:5.0.1'
    }
}

plugins {
    id 'org.springframework.boot' version '2.6.4'
    id 'io.spring.dependency-management' version '1.0.11.RELEASE'
    id 'application'
}

group = 'we.git-implementations'
sourceCompatibility = '17'

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenLocal()
    mavenCentral()
    maven {
        name = 's3Public'
        url = 's3://public.maven.taruts.net'
        credentials(AwsCredentials) {
            accessKey = 'YCAJEr8kG2QLz00ovJC3oeXiQ'
            secretKey = 'YCMRIR338p1YWdI1089MciPfgEc6_lCi2121XaZM'
        }
    }
    maven {
        name = 's3Private'
        url = 's3://maven.taruts.net'
        credentials(AwsCredentials) {
            accessKey = 'YCAJEr8kG2QLz00ovJC3oeXiQ'
            secretKey = 'YCMRIR338p1YWdI1089MciPfgEc6_lCi2121XaZM'
        }
    }
    mavenCentral()
}

dependencies {
    // Dev tools
    developmentOnly 'org.springframework.boot:spring-boot-devtools'

    // Lombok
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'

    // Spring Boot + WebFlux
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'

    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'

    implementation 'we.git-implementations:dynamic-api:001'

    // Our libraries
    implementation 'we:git-utils:001'
    implementation 'we:gradle-utils:001'

    // Utils
    implementation 'org.apache.commons:commons-lang3'
    implementation 'commons-io:commons-io:2.11.0'
    implementation 'com.google.guava:guava:31.1-jre'

    // Test
    testImplementation 'io.projectreactor:reactor-test'
}

tasks.named('test') {
    useJUnitPlatform()
}

enum LocalDynamicGitRepoRemoteType {
    DIRECTORY,
    GITLAB,
}

tasks.register('initDynamicLocal') {
    it.group = 'other-git-repos'

    it.description = '''
    Clones dynamic-dev to other-git-repos/dynamic-local, 
    detaches it from the dynamic-dev remote, 
    then linkes it with a newly created remote other-git-repos/dynamic-local/remote
    which is inside.
    '''.stripIndent()

    it.doLast {
        // Вычисляем, куда мы будем клонироваться
        File dynamicLocalDirectory = java.nio.file.Path
            .of(project.rootDir.path, '../other-git-repos/dynamic-local')
            .toAbsolutePath()
            .normalize()
            .toFile()
        // Удаляем этот каталог, если он есть
        if (dynamicLocalDirectory.exists()) {
            FileUtils.forceDelete(dynamicLocalDirectory)
        }
        FileUtils.forceMkdir(dynamicLocalDirectory)

        // Из основного проекта берем URL репозитория dynamic-dev
        String resourcesDir = project.sourceSets.main.resources.srcDirs.first()
        File dynamicDevPropertiesFile = FileUtils.getFile(resourcesDir, 'application-dynamic-dev.properties')
        def dynamicDevProperties = new Properties()
        try (Reader reader = dynamicDevPropertiesFile.newReader()) {
            dynamicDevProperties.load(reader)
        }
        String dynamicDevRemoteUrlStr = dynamicDevProperties.get('dynamic-impl.git-repository.url')

        // Клонируемся в каталог build/dynamic-impl-dev
        GitUtils.clone(dynamicDevRemoteUrlStr, dynamicLocalDirectory)

        // Ставим пользователя и его мейл
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'config', '--local', 'user.name', 'root')
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'config', '--local', 'user.email', 'root@gmail.com')

        // Изменяем имя проекта и коммитим это
        File settingsGradleFile = FileUtils.getFile(dynamicLocalDirectory, 'settings.gradle')
        FileUtils.writeStringToFile(settingsGradleFile, "rootProject.name = 'dynamic-local'", StandardCharsets.UTF_8)
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'add', '*')
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'commit', '-m', 'Changing project name to dynamic-local')

        LocalDynamicGitRepoRemoteType remoteType = LocalDynamicGitRepoRemoteType.GITLAB

        String remoteUrlStr
        if (remoteType == LocalDynamicGitRepoRemoteType.DIRECTORY) {
            // В каталоге, где должен быть remote, создаем репозиторий
            File remoteDirectory = FileUtils.getFile(dynamicLocalDirectory, 'remote')
            FileUtils.forceMkdir(remoteDirectory)
            ProcessRunner.runProcess(remoteDirectory, 'git', 'init', '--bare')

            // Получаем URL местного удаленного репозитория
            remoteUrlStr = "file://$remoteDirectory"
        } else if (remoteType == LocalDynamicGitRepoRemoteType.GITLAB) {

            // Create a GitLabApi instance to communicate with your GitLab server
            GitLabApi gitLabApi = GitLabApi.oauth2Login('http://localhost:9580', 'user', '123456789', true)

            // Ищем или создаем группу проектов
            String groupPath = 'dynamic-java-stored-in-git'
            Group group = gitLabApi.getGroupApi().getOptionalGroup(groupPath)
                .orElseGet {
                    gitLabApi.getGroupApi().addGroup('Dynamic Java code stored in Git', groupPath)
                }

            org.gitlab4j.api.models.Project gitlabProject

            // Ищем или создаем проект
            String projectName = 'dynamic-dev'
            gitLabApi.getProjectApi().getOptionalProject(groupPath, projectName)
                .ifPresent {
                    gitLabApi.getProjectApi().deleteProject(it.id)
                    println('Waiting for project deletion...')
                    for (i in 60..1) {
                        gitlabProject = gitLabApi.getProjectApi().getOptionalProject(groupPath, projectName).orElse(null)
                        if (gitlabProject != null) {
                            println("$i...")
                            Thread.sleep(1000)
                        }
                    }
                }

            for (i in 100..1) {
                try {
                    gitlabProject = gitLabApi.getProjectApi().createProject(group.id, projectName)
                    break
                } catch (GitLabApiException e) {
                    if (i == 1) {
                        throw e
                    } else {
                        e.validationErrors.forEach { key, value ->
                            println("Gitlab project creation error: attempt $i, key = ${key}, value = ${value}")
                        }
                        Thread.sleep(1000)
                    }
                }
            }

            assert gitlabProject != null

            remoteUrlStr = gitlabProject.getHttpUrlToRepo()
            remoteUrlStr = remoteUrlStr.replaceAll(/((?<=^http?:\/\/)gitlab\.domain\.name\.placeholder(?=\/))/, 'user:123456789@localhost:9580')
        } else {
            throw new IllegalStateException()
        }

        // Перенаправляем remote origin на наш новый репозиторий
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'remote', 'set-url', 'origin', remoteUrlStr)

        // Пушим все в новый репозиторий
        ProcessRunner.runProcess(dynamicLocalDirectory, 'git', 'push', 'origin', 'master')
    }
}

abstract class InitAdjacentGitRepoTask extends DefaultTask {

    @Input
    final String adjacentRepoPostfix

    private String adjacentRepoUrl
    private File sourceDir

    @Inject
    InitAdjacentGitRepoTask(String adjacentRepoPostfix) {
        this.adjacentRepoPostfix = adjacentRepoPostfix

        this.group = 'other-git-repos'

        // Определяем что клонировать. Вычисляем URL репозитория для клонирования, отталкиваясь от URL текущего репозитория
        String startingPointRepoPostfix = 'main'
        String startingPointRepoUrl = ProcessRunner.runProcess(project.rootDir, 'git', 'remote', 'get-url', 'origin')
        adjacentRepoUrl = startingPointRepoUrl.replaceAll(/$startingPointRepoPostfix(?=\.git$)/, adjacentRepoPostfix)

        // Определяем куда клонировать. Нацеливаемся на каталог, где у нас будут лежать исходники
        sourceDir = FileUtils.getFile(project.rootDir.parent, "other-git-repos", adjacentRepoPostfix)

        this.description = "Clones $adjacentRepoUrl into $sourceDir"
    }

    @TaskAction
    def action() {
        GitUtils.forceClone(adjacentRepoUrl, sourceDir)
    }
}

tasks.register('initDynamicApi', InitAdjacentGitRepoTask, 'dynamic-api')
tasks.register('initDynamicDev', InitAdjacentGitRepoTask, 'dynamic-dev')
